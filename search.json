[{"title":"Hello world","url":"/2021/09/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"iOS中alloc和new的本质","url":"/2021/09/29/iOS%E4%B8%ADalloc%E5%92%8Cnew%E7%9A%84%E6%9C%AC%E8%B4%A8/","content":"iOS中的alloc和new\n兄弟们alloc经常会用到。今天看看 objc源码 中是怎么操作的（我用的是 objc818 的，应该是比价新的了）\n\n具体如何使 源码编译,可以移步我的掘金博客源码编译配置 （可以的话点个小赞最好了🤟）\n\n\nalloc 底层原理alloc核心代码定位\n直接搞起了~  首先写行代码\n\nXGPerson * person = [[XGPerson alloc] init];\n\n\n我们可以打断点，然后跟进他的源码，看看他的步骤，然后定位核心代码\n\n\n小谷偷偷的画了一波图\n\n\n\n我们定位到的代码 ~\n\nstatic ALWAYS_INLINE id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,                              int construct_flags = OBJECT_CONSTRUCT_NONE,                              bool cxxConstruct = true,                              size_t *outAllocatedSize = nil)&#123;    ASSERT(cls-&gt;isRealized());    // Read class&#x27;s info bits all at once for performance    bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();    bool hasCxxDtor = cls-&gt;hasCxxDtor();    bool fast = cls-&gt;canAllocNonpointer();    size_t size;    size = cls-&gt;instanceSize(extraBytes);    if (outAllocatedSize) *outAllocatedSize = size;    id obj;    if (zone) &#123;        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);    &#125; else &#123;        obj = (id)calloc(1, size);    &#125;    if (slowpath(!obj)) &#123;        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;            return _objc_callBadAllocHandler(cls);        &#125;        return nil;    &#125;    if (!zone &amp;&amp; fast) &#123;        obj-&gt;initInstanceIsa(cls, hasCxxDtor);    &#125; else &#123;        // Use raw pointer isa on the assumption that they might be        // doing something weird with the zone or RR.        obj-&gt;initIsa(cls);    &#125;    if (fastpath(!hasCxxCtor)) &#123;        return obj;    &#125;    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;    return object_cxxConstructFromClass(obj, cls, construct_flags);&#125;\n\nalloc核心代码探究\n先来一波简单的图片注释说明\n\n\n\n通过上面我们可以知道。alloc主要是3步操作\n\n计算所要开辟内存的大小\n开辟内存空间\n将开辟的空间和isa关联起来（也就是我们说的对象了）\n\n\n我们来看下 开辟内存大小的方法\ninline size_t instanceSize(size_t extraBytes) const &#123;\t//如果已经初始化过了，直接在cache 中取       if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;           return cache.fastInstanceSize(extraBytes);       &#125;       size_t size = alignedInstanceSize() + extraBytes;       // CF requires all objects be at least 16 bytes.       if (size &lt; 16) size = 16;       return size;   &#125;\n\n我们可以发现，他使用的是16字节对齐。\n\n\n我们再来研究下：如何把内存关联起来的。\n\n\ninline void objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)&#123;     ASSERT(!isTaggedPointer());         isa_t newisa(0);    if (!nonpointer) &#123;        newisa.setClass(cls, this);    &#125; else &#123;        ASSERT(!DisableNonpointerIsa);        ASSERT(!cls-&gt;instancesRequireRawIsa());#if SUPPORT_INDEXED_ISA        ASSERT(cls-&gt;classArrayIndex() &gt; 0);        newisa.bits = ISA_INDEX_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else        newisa.bits = ISA_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE#   if ISA_HAS_CXX_DTOR_BIT        newisa.has_cxx_dtor = hasCxxDtor;#   endif        newisa.setClass(cls, this);#endif        newisa.extra_rc = 1;    &#125;    // This write must be performed in a single store in some cases    // (for example when realizing a class because other threads    // may simultaneously try to use the class).    // fixme use atomics here to guarantee single-store and to    // guarantee memory order w.r.t. the class index table    // ...but not too atomic because we don&#x27;t want to hurt instantiation    isa = newisa;&#125;\n\n这就相当于 填充isa了。（里面具体的变量名称。我会在isa博客的时候在叙述~）\n\n\n兄弟们，差不多了。有心的兄弟们可以总结下alloc的流程图。\n\nnew的原理探究new 的流程\n\n首先我们可以看出。new 相比较 alloc 多出一个 init\n\nnew 和 alloc的区别\n\n虽然 allocWithZone 传值不同，但是他不会走~  所以new比alloc单纯了多了一个init\n\n总结\n写这篇博客的时候，有点懒惰了，哈哈。本来想写的在详细点的~\n\n不过哪里写的不好，兄弟们可以评论，以后我写的时候我就会改~\n\n\n","categories":["iOS底层探索之旅"],"tags":["博客 iOS 底层"]},{"title":"iOS中的内存对齐","url":"/2021/10/20/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","content":"内存对齐的定义\n基本所有的程序员，内存对齐 ，基本都会听说过。\n\n内存对齐 是编译器的管辖范围，编译器为程序中的每个数据单元，安排合适的位置。\n\n对于大部分研究过底层的程序员来说，内存对齐 对他们来说都应该是透明的\n\n\n内存对齐的意义\n也是为啥要内存对齐呢？\n\n\n由于本人文采不好，借用下百度百科的解释\n\n\n 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。\n\n 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。\n\n\n内存对齐的规则\n 我也嫌弃文字说明，有麻烦又长，还懒得看~\n我后面会举例说明的。\n\n\n1、数据成员对⻬规则:结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始(比如int为4字节,则要从4的整数倍地址开始存储。 min(当前开始的位置mn) m=9 n=4 那么 9 10 11 12、就要从12开始存储\n\n2、结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b 里有char,int ,double等元素,那b应该从8的整数倍开始存储.)\n\n3、收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补⻬\n\n\n各类型所占字节\n我也知道大家这个表都知道，但是不把图啪上感觉没有仪式感\n\n\n内存对齐举例\n只看理论啥收获都没有感觉，还是不让代码验证解释比较痛快。\n\nexample one :\n\n\n注：&#123;&#125;代表解释说明 。struct XGStruct1 &#123;    double a;   // 8&#123;所占字节数&#125; (0&#123;开始位置&#125;-7&#123;结束位置&#125;)&#123;所占字节位置&#125;    char b;     // 1&#123;所占字节数&#125; [8&#123;开始位置&#125; 1&#123;所占字节数&#125;] (8)&#123;存储字节位置&#125;    int c;      // 4&#123;所占字节数&#125; [9&#123;开始位置&#125; 4&#123;所占字节数&#125;] 9 10 11 (12 13 14 15)&#123;存储字节位置&#125;    short d;    // 2&#123;所占字节数&#125; [16&#123;开始位置&#125; 2&#123;所占字节数&#125;] (16 17)&#123;存储字节位置&#125;&#125;struct1;解释说明：内存对齐规则1：开始位置必须是所占字节数的整数倍，才能开始存。（举例：char b,由于开始位置是所占字节数的整数倍可以直接存，int c ，开始位置是从9，并不是4的整数倍，所以从12开始存）存储大小是：18&#123;0-17&#125;由于结构体中存在double为最大字节数：8（内存对齐规则3：所占内存必须是最大字节数的整数倍。所以必须是8的整数倍。18--&gt;24）所以所占内存大小是24.\n\n输出log ， 确认下\n\nNSLog(@&quot;%lu&quot;,sizeof(struct1));log输出：24\n\n\nexample two:\n\n\n这个应该就比较形象了~\n\nstruct XGStruct2 &#123;    int b;      //4&#123;所占字节数&#125; [0&#123;开始位置&#125; 4&#123;所占字节数&#125;],(0 1 2 3)&#123;存储字节位置&#125;    char c;     //1&#123;所占字节数&#125; [4&#123;开始位置&#125; 1&#123;所占字节数&#125;], (4)&#123;存储字节位置&#125;    short d;    //2&#123;所占字节数&#125; [5&#123;开始位置&#125; 2&#123;所占字节数&#125;], 5 (6 7)&#123;存储字节位置&#125;    short e;    //2&#123;所占字节数&#125; [8&#123;开始位置&#125; 2&#123;所占字节数&#125;], (8 9)&#123;存储字节位置&#125;&#125;struct2;解释说明：1、内存所占大小是 10（0-9）2、内存中最大的字节是int（4），所以是4的整数倍。理论结果：12验证：NSLog(@&quot;%lu&quot;,sizeof(struct2));输出：12\n\n兄弟们已经完美掌握了 内存对齐 了\n\n内存对齐规则的扩展\n以上2个例子应该可以说明内存对齐规则了。我相信大家也都懂了。那么，咱们来一波进阶： 结构体嵌套结构体 \n\n\n用上面的例子修改下~\n\nstruct XGStruct1 &#123;    double a;     char b;      int c;         short d;    &#125;struct1;//已证struct XGStruct2 &#123;    int b;          char c;         short d;        short e;    &#125;struct2;//已证我们把XGStruct2 改变下，加入XGStruct1,变成XGStruct3:struct XGStruct3 &#123;    int b;          char c;         short d;        short e;    struct XGStruct1 xgs;&#125;struct3;大家可以先想想下，所占内存大小？\n\n\n开始解释了啊~\n\n\n首先。我们先通过规则，大概猜一下，会是什么样子的.\n\n先换一种好说明的写法struct XGStruct3 &#123;    int b;      //4&#123;所占字节数&#125; [0&#123;开始位置&#125; 4&#123;所占字节数&#125;],(0 1 2 3)&#123;存储字节位置&#125;    char c;     //1&#123;所占字节数&#125; [4&#123;开始位置&#125; 1&#123;所占字节数&#125;], (4)&#123;存储字节位置&#125;    short d;    //2&#123;所占字节数&#125; [5&#123;开始位置&#125; 2&#123;所占字节数&#125;], 5 (6 7)&#123;存储字节位置&#125;    short e;    //2&#123;所占字节数&#125; [8&#123;开始位置&#125; 2&#123;所占字节数&#125;], (8 9)&#123;存储字节位置&#125;    struct XGStruct4 &#123;        double a;// [10 8] 10 11 12 13 14 15 (16 17 18 19 20 21 22 23)        int b;   // [24 4] (24 25 26 27)        char c;  // [28 1] (28)        short d; // [29 2] 29 (30 31)    &#125;xgs;&#125;struct3;所占大小是32 （0-31）里面最大类型是double（8），又是8的倍数，那岂不是结果是32，验证一波：NSLog(@&quot;%lu&quot;,sizeof(struct3));输出：32还真是！！！！！\n\n兄弟们可以自己写一些例子来辅证下~。\n","categories":["iOS底层探索之旅"],"tags":["博客 iOS 底层"]},{"title":"我的第一篇","url":"/2021/09/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/","content":"原因\n原先经常在掘金上写博客发表文章。但是每次在阅读大佬博客的时候，都是有自己的博客。\n\n试着想了想，还是自己搭个博客吧 – 必须要向大佬看起\n\n小谷我呢，其实写代码不是那么热衷，我比较喜欢研究。所以不写博客感觉会总是遗忘一些知识点。\n\n\n总结\n希望可以通过写博客来加深注意力。\n\n当然主要是忘记的话，有个地方查\n\n希望大牛大佬多多指点。由于这段时间我也不太清楚自己要研究什么了。\n\n\n"},{"title":"联合体&位域","url":"/2021/10/20/%E8%81%94%E5%90%88%E4%BD%93-%E4%BD%8D%E5%9F%9F/","content":"联合体&amp;位域\n在iOS中有个非常有名的东西–isa, 不知道兄弟们有没有研究过这个东西。isa的结构就是通过联合体和位域构成的。\n\n今天小小的研究一波，我感觉这个只需要看懂就可以了。日常开发基本用不到。\n\n\n联合体\n我们平常会用到一个类型成为结构体(struct)，有一种和结构体相似的结构为共用体,我们也称为联合体\n\nunion 共用体名 &#123;    成员列表&#125;\n\n\n联合体 相似于 结构体，但是也不同于 结构体\n\n联合体 和 结构体 的区别 1\n结构体 中每个成员都独立一块内存，相互不影响！\n\n联合体 所有成员公用一块内存！牵一而动全身\n\n举例说明：\n\n\nunion XGXS &#123;    int a;      //4个字节    short b;    //2个字节    char c;     //1个字节&#125; xgxs;//结果xgxs.a = 2;xgxs.b = 4;xgxs.c = &#x27;c&#x27;;NSLog(@&quot;union size: %lu - %lu&quot;,sizeof(xgxs), sizeof(union XGXS));//union size: 4 - 4\n\n 得出结论1：联合体的内存是成员所需的最大内存那个。\n\n联合体 和 结构体 的区别 2xgxs.a = 2;NSLog(@&quot;%d---%d---%c&quot;,xgxs.a,xgxs.b,xgxs.c);//2---2---\u0002xgxs.b = 4;NSLog(@&quot;%d---%d---%c&quot;,xgxs.a,xgxs.b,xgxs.c);//4---4---\u0004xgxs.c = &#x27;c&#x27;;NSLog(@&quot;%d---%d---%c&quot;,xgxs.a,xgxs.b,xgxs.c);//99---99---c\n\n\n得出结论2：每次改变联合体中的成员，其他成员会受到影响、即联合体成员之间是相互互斥的\n\n位域\n位域 就比较好理解了，见名知意~\n\n举个例子：假如我有一辆拖拉机！这个拖拉机的方向只能 前、后、左、右\n\n\n使用bool\n直接上代码了\n\n@interface XGTractor : NSObject@property (nonatomic, assign) BOOL front;@property (nonatomic, assign) BOOL back;@property (nonatomic, assign) BOOL left;@property (nonatomic, assign) BOOL right;@end@implementation XGTractor@endXGTractor *tractor = [[XGTractor alloc] init];tractor.back = YES;tractor.front = YES;tractor.left = YES;tractor.right = YES;\n\n\n我们打印这个 tractor\n\n\n\n然后我们发现了：我们可以看到 front、back、left、right 各占一个字节，但其实我们只需要一个二进制就可以表现出来，也就是0或 1就可以!\n\n这个时候我们就可以使用 位域 来看一下了\n\n\n使用位域\n上代码\n\n@interface XGTractor2 : NSObject- (void)setFront:(BOOL)isFront;- (BOOL)isFront;- (void)setBack:(BOOL)isBack;- (BOOL)isBack;- (void)setLeft:(BOOL)isLeft;- (BOOL)isLeft;- (void)setRight:(BOOL)isRight;- (BOOL)isRight;@end#define XGDirectionFrontMask (1 &lt;&lt; 0)#define XGDirectionBackMask  (1 &lt;&lt; 1)#define XGDirectionLeftMask  (1 &lt;&lt; 2)#define XGDirectionRightMask (1 &lt;&lt; 3)@interface XGTractor2 () &#123;    union &#123;        char bits;        struct &#123;            char front: 1;            char back:  1;            char left:  1;            char right: 1;        &#125;;    &#125; _direction;&#125;@end@implementation XGTractor2- (instancetype)init &#123;    self = [super init];    if (self) &#123;        _direction.bits = 0b00000000;    &#125;    return self;&#125;- (void)setFront:(BOOL)isFront &#123;    _direction.front = isFront;&#125;- (BOOL)isFront &#123;    return !!(_direction.bits &amp; XGDirectionFrontMask);&#125;- (void)setBack:(BOOL)isBack &#123;    _direction.back = isBack;&#125;- (BOOL)isBack &#123;    return !!(_direction.back &amp; XGDirectionBackMask);&#125;- (void)setLeft:(BOOL)isLeft &#123;    _direction.left = isLeft;&#125;- (BOOL)isLeft &#123;    return !!(_direction.left &amp; XGDirectionLeftMask);&#125;- (void)setRight:(BOOL)isRight &#123;    _direction.right = isRight;&#125;- (BOOL)isRight &#123;    return !!(_direction.left &amp; XGDirectionLeftMask);&#125;@end\n\n\n使用\n\nXGTractor2 *tr2 = [[XGTractor2 alloc] init];tr2.front = 1;tr2.back = 1;tr2.left = 1;tr2.right = 1;\n\n然后我们看下结果\n\n\n\n然后我画了个图，比较生动形象~\n\n\n\n这种结构就是 位域 了\n\n","categories":["iOS底层探索之旅"],"tags":["博客 iOS 底层"]}]