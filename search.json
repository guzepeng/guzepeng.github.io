[{"title":"Hello world","url":"/2021/09/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"iOS中alloc和new的本质","url":"/2021/09/29/iOS%E4%B8%ADalloc%E5%92%8Cnew%E7%9A%84%E6%9C%AC%E8%B4%A8/","content":"iOS中的alloc和new\n兄弟们alloc经常会用到。今天看看 objc源码 中是怎么操作的（我用的是 objc818 的，应该是比价新的了）\n\n具体如何使 源码编译,可以移步我的掘金博客源码编译配置 （可以的话点个小赞最好了🤟）\n\n\nalloc 底层原理alloc核心代码定位\n直接搞起了~  首先写行代码\n\nXGPerson * person = [[XGPerson alloc] init];\n\n\n我们可以打断点，然后跟进他的源码，看看他的步骤，然后定位核心代码\n\n\n小谷偷偷的画了一波图\n\n\n\n我们定位到的代码 ~\n\nstatic ALWAYS_INLINE id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,                              int construct_flags = OBJECT_CONSTRUCT_NONE,                              bool cxxConstruct = true,                              size_t *outAllocatedSize = nil)&#123;    ASSERT(cls-&gt;isRealized());    // Read class&#x27;s info bits all at once for performance    bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();    bool hasCxxDtor = cls-&gt;hasCxxDtor();    bool fast = cls-&gt;canAllocNonpointer();    size_t size;    size = cls-&gt;instanceSize(extraBytes);    if (outAllocatedSize) *outAllocatedSize = size;    id obj;    if (zone) &#123;        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);    &#125; else &#123;        obj = (id)calloc(1, size);    &#125;    if (slowpath(!obj)) &#123;        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;            return _objc_callBadAllocHandler(cls);        &#125;        return nil;    &#125;    if (!zone &amp;&amp; fast) &#123;        obj-&gt;initInstanceIsa(cls, hasCxxDtor);    &#125; else &#123;        // Use raw pointer isa on the assumption that they might be        // doing something weird with the zone or RR.        obj-&gt;initIsa(cls);    &#125;    if (fastpath(!hasCxxCtor)) &#123;        return obj;    &#125;    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;    return object_cxxConstructFromClass(obj, cls, construct_flags);&#125;\n\nalloc核心代码探究\n先来一波简单的图片注释说明\n\n\n\n通过上面我们可以知道。alloc主要是3步操作\n\n计算所要开辟内存的大小\n开辟内存空间\n将开辟的空间和isa关联起来（也就是我们说的对象了）\n\n\n我们来看下 开辟内存大小的方法\ninline size_t instanceSize(size_t extraBytes) const &#123;\t//如果已经初始化过了，直接在cache 中取       if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;           return cache.fastInstanceSize(extraBytes);       &#125;       size_t size = alignedInstanceSize() + extraBytes;       // CF requires all objects be at least 16 bytes.       if (size &lt; 16) size = 16;       return size;   &#125;\n\n我们可以发现，他使用的是16字节对齐。\n\n\n我们再来研究下：如何把内存关联起来的。\n\n\ninline void objc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)&#123;     ASSERT(!isTaggedPointer());         isa_t newisa(0);    if (!nonpointer) &#123;        newisa.setClass(cls, this);    &#125; else &#123;        ASSERT(!DisableNonpointerIsa);        ASSERT(!cls-&gt;instancesRequireRawIsa());#if SUPPORT_INDEXED_ISA        ASSERT(cls-&gt;classArrayIndex() &gt; 0);        newisa.bits = ISA_INDEX_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE        newisa.has_cxx_dtor = hasCxxDtor;        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else        newisa.bits = ISA_MAGIC_VALUE;        // isa.magic is part of ISA_MAGIC_VALUE        // isa.nonpointer is part of ISA_MAGIC_VALUE#   if ISA_HAS_CXX_DTOR_BIT        newisa.has_cxx_dtor = hasCxxDtor;#   endif        newisa.setClass(cls, this);#endif        newisa.extra_rc = 1;    &#125;    // This write must be performed in a single store in some cases    // (for example when realizing a class because other threads    // may simultaneously try to use the class).    // fixme use atomics here to guarantee single-store and to    // guarantee memory order w.r.t. the class index table    // ...but not too atomic because we don&#x27;t want to hurt instantiation    isa = newisa;&#125;\n\n这就相当于 填充isa了。（里面具体的变量名称。我会在isa博客的时候在叙述~）\n\n\n兄弟们，差不多了。有心的兄弟们可以总结下alloc的流程图。\n\nnew的原理探究new 的流程\n\n首先我们可以看出。new 相比较 alloc 多出一个 init\n\nnew 和 alloc的区别\n\n虽然 allocWithZone 传值不同，但是他不会走~  所以new比alloc单纯了多了一个init\n\n总结\n写这篇博客的时候，有点懒惰了，哈哈。本来想写的在详细点的~\n\n不过哪里写的不好，兄弟们可以评论，以后我写的时候我就会改~\n\n\n","categories":["iOS底层探索之旅"],"tags":["博客 iOS 底层"]},{"title":"我的第一篇","url":"/2021/09/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/","content":"原因\n原先经常在掘金上写博客发表文章。但是每次在阅读大佬博客的时候，都是有自己的博客。\n\n试着想了想，还是自己搭个博客吧 – 必须要向大佬看起\n\n小谷我呢，其实写代码不是那么热衷，我比较喜欢研究。所以不写博客感觉会总是遗忘一些知识点。\n\n\n总结\n希望可以通过写博客来加深注意力。\n\n当然主要是忘记的话，有个地方查\n\n希望大牛大佬多多指点。由于这段时间我也不太清楚自己要研究什么了。\n\n\n"}]